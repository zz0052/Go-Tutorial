### For-learning-Go-Tutorial

Go语言是谷歌2009发布的第二款开源编程语言

Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

因而一直想的是自己可以根据自己学习和使用Go语言编程的心得，写一本Go的书可以帮助想要学习Go语言的初学者快速入门开发和使用！
#### Grpc与Protobuf
```markdown
A high performance, open source, general RPC framework that puts mobile and HTTP/2 first.
```
Grpc 是一个高性能、开源、通用的RPC框架，由Google推出，基于HTTP/2协议标准设计开发，默认采用Protocol Buffers数据序列化协议，支持多种开发语言。gRPC提供了一种简单的方法来精确的定义服务，并且为客户端和服务端自动生成可靠的功能库。

Grpc主要特点：

* Grpc使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。

* Grpc支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。

* Grpc基于HTTP/2标准设计，所以相对于其他RPC框架，Grpc带来了更多强大功能，如双向流、头部压缩、多复用请求等。这些功能给移动设备带来重大益处，如节省带宽、降低TCP链接次数、节省CPU使用和延长电池寿命等。同时，Grpc还能够提高了云端服务和Web应用的性能。Grpc既能够在客户端应用，也能够在服务器端应用，从而以透明的方式实现客户端和服务器端的通信和简化通信系统的构建。

在Grpc客户端中可以直接调用不同服务器上的远程程序，使用姿势看起来就像调用本地程序一样，很容易去构建分布式应用和服务。和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用Grpc支持的不同语言实现。

然而编译Grpc需要Protobufer编译器,那么Protobufer又是什么呢?


<p align="center">
<img width="100%" align="center" src="../images/30.jpg" />
</p>

Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。

Protocol buffers 在序列化数据方面，它是灵活的，高效是一种轻便高效的结构化数据存储格式。相比较于 XML 来说，Protocol buffers 更加小巧,简单。当你定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至你也可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。Protocol buffers可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。


protocol buffers的特性：
* 自动生成的序列化和反序列化代码避免了手动解析。
* 除用于 RPC（远程过程调用）请求之外，现在开始将protocol buffers 用作持久存储数据的便捷自描述格式（例如，在Bigtable中）。
* 服务器的 RPC 接口可以先声明为协议的一部分，然后用 protocol compiler 生成基类，用户可以使用服务器接口的实际实现来覆盖它们。

#### proto3 定义 message

Protobuf 语法定义:

要想使用protobuf必须得先定义proto文件。所以得先熟悉protobuf的消息定义的相关语法。下面就来介绍
首先我们先定义一个proto文件，结构如下：

```protobufer
syntax = "proto3";

package pb;

service NewService {
   string msn = 1;
   string streamKey = 2;
}
```

* 文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。
* NewService消息格式有2个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。

#### 分配字段编号
在NewService所有字段都是标量类型：两个string类型msn 和 streamKey。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。
正如消息中的结构每个消息定义中的每个字段都有唯一的编号。这些字段编号用于标识消息二进制格式中的字段，并且在使用消息类型后不应更改。这里需要注意下，范围 1 到 15 中的字段编号需要一个字节进行编码，包括字段编号和字段类型．范围 16 至 2047 中的字段编号需要两个字节。所以你应该保留数字 1 到 15 作为非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。

最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。

#### 指定字段规则
所指定的消息字段修饰符必须是如下之一：

* singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）.
* repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。

在proto3中，repeated的标量域默认情况下可以使用packed.如果想要了解更多可以查看[Protocol Buffer编码原理](具体原因见 Protocol Buffer 编码原理 ).

#### 保留标识符（Reserved）
如果你通过删除或者注释所有域，以后的用户可以重用标识号当你重新更新类型的时候。如果你使用旧版本加载相同的.proto文件这会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是指定保留标识符（and/or names, which can also cause issues for JSON serialization不明白什么意思），protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。
```go
message Foo {
  reserved 2, 7, 9 to 11;
  reserved "foo", "bar";
}
```
注意：不要在同一行reserved声明中同时声明域名字和标识号

#### 各个语言标量类型对应关系

<p align="center">
<img width="100%" align="center" src="../images/31.jpg" />
</p>
