### For-learning-Go-Tutorial

Go语言是谷歌2009发布的第二款开源编程语言

Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

因而一直想的是自己可以根据自己学习和使用Go语言编程的心得，写一本Go的书可以帮助想要学习Go语言的初学者快速入门开发和使用！

#### 复合数据类型

复合数据类型有:
* [数组](#数组)
* [Slice](#Slice)
* [Map](#Map)
* [结构体](#结构体)
* [JSON](#JSON)
#### 数组

在复合数据类型中数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。由于数组的长度是固定的，因而在使用的时候我们用的最多的是slice（切片），它是可以增长和收缩动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。

数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。

数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。

```
var m [3]int = [3]int{1, 2, 3}
var n [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的
个数来计算。

```
m := [...]int{1, 2, 3}
fmt.Printf("%T\n", m) // "[3]int"
```
数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

数组可以直接进行比较，当数组内的元素都一样的时候表示两个数组相等。
```go
arr1 := [3]int{1, 2, 3}
arr2 := [3]int{1, 2, 3}
arr3 := [3]int{1, 2, 4} 
fmt.Println(arr1 == arr2, arr1 == arr3)  //true,false
```
数组可以作为函数的参数传入，但由于数组在作为参数的时候，其实是进行了拷贝，这样在函数内部改变数组的值，是不影响到外面的数组的值得。
```go
func ArrIsArgs(arr [4]int) {
    arr[0] = 120
}
m := [...]int{1, 2, 3, 4}
ArrIsArgs(m)
```
如果想要改变就只能使用指针，在函数内部改变的数组的值，也会改变外面的数组的值：
```
func ArrIsArgs(arr *[4]int) {
   arr[0] = 20
}
m:= [...]int{1, 2, 3, 4}
ArrIsArgs(&m)
```

通常这样的情况下都是用切片来解决，而不是用数组。

#### Slice
Slice(切片)代表变长的序列,序列中每个元素都有相同的类型。一个slice类型一般写作[]T,其中T代表slice中元素的类型;slice的语法和数组很像,只是没有固定长度而已。

数组和slice关系非常密切，一个slice可以访问数组的部分或者全部数据，而且slice的底层本身就是对数组的引用。

一个Slice由三部分组成：指针，长度和容量。内置的len和cap函数可以分别返回slice的长度和容量。指针指向第一个slice元素对应的底层数组元素的地址,要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目;长度不能超过容量,容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

slice的切片操作s[i:j],其中0 ≤ i≤ j≤ cap(s),用于创建一个新的slice,引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替,如果j位置的索引被省略的话将使用len(s)代替。

slice创建方式主要有两种：1.基于数组创建。2.直接创建

* 基于数组创建：
```go
arrVar := [4]int{1, 2, 3，4}
sliceVar := arrVar[1:3]
```
数组arrVar和sliceVar里面的地址其实是一样的，因而如果你改变sliceVar里面的变量，那么arrVar里面的变量也会随之改变。

* 直接创建

可以使用内置的make()函数来创建。事实上还是会创建一个匿名的数组，只是不需要我们来定义。

```go
slice1 := make([ ]int,5)//创建一个元素个数5的slice,cap也是5
slice2 := make([ ]int,5,10)//创建一个元素个数5的slice，cap是10
slice3 := [ ]int{1,2,3,4,5}//创建一个元素个数为5的slice，cap是5
var slice []int //创建一个空的slice，cap和len都是0
```

