
### For-learning-Go-Tutorial

Go语言是谷歌2009发布的第二款开源编程语言

Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

因而一直想的是自己可以根据自己学习和使用Go语言编程的心得，写一本Go的书可以帮助想要学习Go语言的初学者快速入门开发和使用！

#### 复合数据类型

复合数据类型有:
* [数组](#数组)
* [Slice](#Slice)
* [Map](#Map)
* [结构体](#结构体)
* [JSON](#JSON)
#### 数组

在复合数据类型中数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。由于数组的长度是固定的，因而在使用的时候我们用的最多的是slice（切片），它是可以增长和收缩动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。

数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。

数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。

```
var m [3]int = [3]int{1, 2, 3}
var n [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的
个数来计算。

```
m := [...]int{1, 2, 3}
fmt.Printf("%T\n", m) // "[3]int"
```
数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

数组可以直接进行比较，当数组内的元素都一样的时候表示两个数组相等。
```go
arr1 := [3]int{1, 2, 3}
arr2 := [3]int{1, 2, 3}
arr3 := [3]int{1, 2, 4} 
fmt.Println(arr1 == arr2, arr1 == arr3)  //true,false
```
数组可以作为函数的参数传入，但由于数组在作为参数的时候，其实是进行了拷贝，这样在函数内部改变数组的值，是不影响到外面的数组的值得。
```go
func ArrIsArgs(arr [4]int) {
    arr[0] = 120
}
m := [...]int{1, 2, 3, 4}
ArrIsArgs(m)
```
如果想要改变就只能使用指针，在函数内部改变的数组的值，也会改变外面的数组的值：
```
func ArrIsArgs(arr *[4]int) {
   arr[0] = 20
}
m:= [...]int{1, 2, 3, 4}
ArrIsArgs(&m)
```

通常这样的情况下都是用切片来解决，而不是用数组。

#### Slice
Slice(切片)代表变长的序列,序列中每个元素都有相同的类型。一个slice类型一般写作[]T,其中T代表slice中元素的类型;slice的语法和数组很像,只是没有固定长度而已。

数组和slice关系非常密切，一个slice可以访问数组的部分或者全部数据，而且slice的底层本身就是对数组的引用。

一个Slice由三部分组成：指针，长度和容量。内置的len和cap函数可以分别返回slice的长度和容量。指针指向第一个slice元素对应的底层数组元素的地址,要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目;长度不能超过容量,容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

多个slice之间可以共享底层的数据,并且引用的数组部分区间可能重叠。图4.1显示了表示一
年中每个月份名字的字符串数组,还有重叠引用了该数组的两个slice。数组这样定义.

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

一月份是months[1],十二月份是months[12]。通常,数组的第一个元素从索引0开始,但是月份一般是从1开始的,因此我们声明数组时直接跳过第0个元素,第0个元素会被自动初始化为空字符串。

<p align="center">
<img width="500" align="center" src="../images/6.jpg" />
</p>


slice的切片操作s[i:j],其中0 ≤ i≤ j≤ cap(s),用于创建一个新的slice,引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替,如果j位置的索引被省略的话将使用len(s)代替。
如果切片操作超出cap(s)的上限将导致一个panic异常,但是超出len(s)则是意味着扩展了lice,因为新slice的长度会变大.

slice创建方式主要有两种：1.基于数组创建。2.直接创建

* 基于数组创建：
```go
arrVar := [4]int{1, 2, 3，4}
sliceVar := arrVar[1:3]
```
数组arrVar和sliceVar里面的地址其实是一样的，因而如果你改变sliceVar里面的变量，那么arrVar里面的变量也会随之改变。

* 直接创建

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略,在这种情况下,容量将等于长度。

使用内置的make()函数来创建。事实上还是会创建一个匿名的数组，只是不需要我们来定义。
```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```
在底层,make创建了一个匿名的数组变量,然后返回一个slice;只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中,slice是整个数组的view。在第二个语句中,slice只引用了底层数组的前len个元素,但是容量将包含整个的数组。额外的元素是留给未来的增长用的。

```go
slice1 := make([ ]int,5)//创建一个元素个数5的slice,cap也是5
slice2 := make([ ]int,5,10)//创建一个元素个数5的slice，cap是10
slice3 := [ ]int{1,2,3,4,5}//创建一个元素个数为5的slice，cap是5
var slice []int //创建一个空的slice，cap和len都是0
```

和数组不同的是,slice之间不能比较,因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等([]byte),但是对于其他类型的slice,我们必须自己展开每个元素进行比较:

```go
func equal(x, y []string) bool {
   if len(x) != len(y) {
        return false
   }
   for i := range x {
        if x[i] != y[i] {
            return false
        }
  }
  return true
}
```

通过在slice的深度相等测试,运行的时间并不比支持==操作的数组或字符串更多,但是为何slice不直接支持比较运算符呢?这方面有两个原因。第一个原因,一个slice的元素是间接引用的,一个slice甚至可以包含自身。虽然有很多办法处理这种情形,但是没有一个是简单有效的。

第二个原因,因为slice的元素是间接引用的,一个固定值的slice在不同的时间可能包含不同的元素,因为底层数组的元素可能会被修改。并且Go语言中map等哈希表之类的数据结构的key只做简单的浅拷贝,它要求在整个声明周期中相等的key必须对相同的元素。对于像指针或chan之类的引用类型,==相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的==操作符可能是有一定用处的,也能临时解决map类型的key问题,但是slice和数组不同的相等测试行为会让人困惑。因此,安全的做法是直接禁止slice之间的比较操作。

slice唯一合法的比较操作是和nil比较,例如:
```go
if slice == nil { /* ... */ }
```
一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0,但是也有非nil值的slice的长度和容量也是0的,例如[]int{}或make([]int, 3)[3:]。与任意类型的nil值一样,我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。

```go
var s []int      // len(s) == 0, s == nil
s = nil         // len(s) == 0, s == nil
s = []int(nil)  // len(s) == 0, s == nil
s = []int{}     // len(s) == 0, s != nil
```

如果你需要测试一个slice是否是空的,使用len(s) == 0来判断,而不应该用s == nil来判断。除了和nil相等比较外,一个nil值的slice的行为和其它任意0长度的slice一样.

此外Slice切片还有append函数用于向slice追加元素.虽然Slice是可以动态扩展的。但Slice的动态扩展是有代价的，也就是说如果在确定大小的前提下，最好是设置好slice的cap大小.

```go
func main() {
    var x, y []int
    for i := 0; i < 10; i++ {
        y = appendInt(x, i)
        fmt.Printf("%d cap=%d\t%v\n", i, cap(y), y)
        x = y
    }
}
```
每一次容量的变化都会导致重新分配内存和copy操作:
```go
0 cap=1 [0]
1 cap=2 [0 1]
2 cap=4 [0 1 2]
3 cap=4 [0 1 2 3]
4 cap=8 [0 1 2 3 4]
5 cap=8 [0 1 2 3 4 5]
6 cap=8 [0 1 2 3 4 5 6]
7 cap=8 [0 1 2 3 4 5 6 7]
8 cap=16 [0 1 2 3 4 5 6 7 8]
9 cap=16 [0 1 2 3 4 5 6 7 8 9]
```
我们仔细查看i=3次的迭代。当时x包含了[0 1 2]三个元素,但是容量是4,因此可以简单将新的元素添加到末尾,不需要新的内存分配。然后新的y的长度和容量都是4,并且和x引用着相同的底层数组.

<p align="center">
<img width="500" align="center" src="../images/7.jpg" />
</p>

在下一次迭代时i=4,现在没有新的空余的空间了,因此appendInt函数分配一个容量为8的底层数组,将x的4个元素[0 1 2 3]复制到新空间的开头,然后添加新的元素i,新元素的值是4。新的y的长度是5,容量是8;后面有3个空闲的位置,三次迭代都不需要分配新的空间。当前迭代中,y和x是对应不同底层数组的view。

<p align="center">
<img width="500" align="center" src="../images/8.jpg" />
</p>

当slice的的容量等于len的时候，cap是翻倍了。append的底层原理就是当slice的容量满了的时候，重新建立一块内存，然后将原来的数据拷贝到新建的内存。所以说容量的扩充是存在内存的建立和复制的。该过程将会影响到系统的运行速度。

更新slice变量不仅对调用append函数是必要的,实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice,需要记住尽管底层数组的元素是间接访问的,但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看,slice并不是一个纯粹的引用类型,它实际上是一个类似下面结构体的聚合类型:

```go
type IntSlice struct {
    ptr         *int
    len, cap    int
}
```

我们的appendInt函数每次只能向slice追加一个元素,但是内置的append函数则可以追加多个元素,甚至追加一个slice。

```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)     // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

通过这样的修改我们可以可以达到append函数类似的功能。其中在appendInt函数参数中的最后的“...”省略号表示接收变长的参数为slice。

内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。使用copy函数：。
```go
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
```
copy函数的第一个参数是要复制的目标slice,第二个参数是源slice,目标和源的位置顺序和dst = src赋值语句是一致的。两个slice可以共享同一个底层数组,甚至有重叠也没有问题。copy函数将返回成功复制的元素的个数(我们这里没有用到),等于两个slice中较小的长度,所以我们不用担心覆盖会超出目标slice的范围。

#### Slice使用技巧
 Slice的使用方式有很多例如旋转slice、反转slice或在slice原有内存空间修改元素。
给定一个字符串列表,下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表:

```go
// Nonempty is an example of an in-place slice algorithm.
package main
import "fmt"
// nonempty returns a slice holding only the non-empty strings.
// The underlying array is modified during the call.
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
         if s != "" {
            strings[i] = s
         i++
        }
    }
    return strings[:i]
}

```

比较微妙的地方是,输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数
组,不过原来的数据将可能会被覆盖,正如下面两个打印语句看到的那样:
```go
data := []string{"1", "", "3"}
fmt.Printf("%q\n", nonempty(data)) // `["1" "3"]`
fmt.Printf("%q\n", data)
// `["1" "3" "3"]`
```
因此我们通常会这样使用nonempty函数:data = nonempty(data)。 
nonempty函数也可以使用append函数实现:
```go
func nonempty2(strings []string) []string {
out := strings[:0] // zero-length slice of original
    for _, s := range strings {
        if s != "" {
            out = append(out, s)
        }
    }
    return out
}
```
无论如何实现,以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值,事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧,虽然使用到了slice的一些技巧,但是对于某些场合是比较清晰和有效的。

一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack,然后可以使用append函数将新的值压入stack:
```go
stack = append(stack, v) // push v
```
stack的顶部位置对应slice的最后一个元素:
```go
top := stack[len(stack)-1] // top of stack
```
通过收缩stack可以弹出栈顶的元素:
```go
stack = stack[:len(stack)-1] // pop
```

要删除slice中间的某个元素并保存原有的元素顺序,可以通过内置的copy函数将后面的子slice向前依次移动一位完成:
```go
func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])
    return slice[:len(slice)-1]
}
func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 8 9]"
}
```
如果删除元素后不用保持原来顺序的话,我们可以简单的用最后一个元素覆盖被删除的元素:

```go
func remove(slice []int, i int) []int {
    slice[i] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}
func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 9 8]
}
```
如果要反转整个slice的元素:
```go
s := []int{0, 1, 2, 3, 4, 5}
reverse(s)
fmt.Println(s) // "[5 4 3 2 1 0]"
```

#### Map
哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合,其中所有的key都是不同的,然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

在Go语言中,一个map就是一个哈希表的引用,map类型可以写为map[K]V,其中K和V分别对应key和value。map中所有的key都有相同的类型,所有的value也有着相同的类型,但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在。

1. Map的声明
```go
var m map[string] string
```
m是声明的变量名，sting是对应的Key的类型，string是value的类型。

2. 创建

Go内置的make函数可以创建map:

```go
 m := make(map[string]int) 
```

我们也可以用map字面值的语法创建map,同时还可以指定一些最初的key/value:
```go
m := map[string]int{
"keke": 001,
"jame": 002,
}
```
这个等价于:
```go
m := make(map[string]int)
m["keke"] = 001
m["jame"] = 002
```
另外一种创建map的方式是map[string]int{}。

3.元素的删除

Map可以使用内置的delete函数可以删除元素:
```go
delete(ages, "jame") //可以删除m["jame"]
```

而且x += y和x++等简短赋值语法也可以用在map上,所以上面的代码可以改写成:
```go
ages["keke"] += 1
```
更简单的写法:
```go
m["keke"]++
```
但是map中的元素并不是一个变量,因此我们不能对map的元素进行取址操作:
```
_ = &ages["keke"] // compile error: cannot take address of map element
```
禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间,从而可能导致之前的地址无效。

要想遍历map中全部的key/value对的话,可以使用range风格的for循环实现,和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量,它们对应下一个键/值对:
```go
for k, v := range m {
    fmt.Printf("%s\t%d\n", k, v)
}
```

Map的迭代顺序是不确定的,并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中,遍历的顺序是随机的,每一次遍历的顺序都不相同。这是故意的,每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对,我们必须显式地对key进行排序,可以使用sort包的Strings函数对字符串slice进行排序。常见的处理方式:

```go
import "sort"

var names []string
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```


