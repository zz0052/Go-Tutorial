### For-learning-Go-Tutorial

Go语言是谷歌2009发布的第二款开源编程语言

Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

因而一直想的是自己可以根据自己学习和使用Go语言编程的心得，写一本Go的书可以帮助想要学习Go语言的初学者快速入门开发和使用！


#### Etcd的使用

Etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。Etcd内部采用Raft协议作为一致性算法，Etcd基于Go语言实现。

Etcd作为服务发现系统，主要特点：

* 简单：安装配置简单，而且提供了HTTP API进行交互，使用也很简单.
* 安全：支持SSL证书验证.
* 快速：根据官方提供的Benchmark数据，单实例支持每秒2k+读操作.
* 可靠：采用Raft算法，实现分布式系统数据的可用性和一致性.

Etcd的主要功能：
* 基本的key-value存储.
* 监听机制.
* key的过期及续约机制，用于监控和服务发现.
* 原子CAS和CAD，用于分布式锁和leader选举.

#### Etcd单节点安装

通常情况下Etcd在生产环境中一般推荐集群方式部署。但是为了方便和初学者使用这里讲述的是单节点Etcd安装和基本使用。
Etcd目前默认使用2379端口提供HTTP API服务，2380端口和Peer通信(这两个端口已经被IANA官方预留给Etcd)；在之前的版本中可能会分别使用4001和7001，在使用的过程中需要注意这个区别。

由于Etcd 基于Go语言实现，因此，用户可以从Etcd项目主页下载源代码自行编译，也可以下载编译好的二进制文件，甚至直接使用制作好的Docker镜像文件来体验。

这里我用二进制文件来安装,编译好的二进制文件都在[Etcd](https://github.com/coreos/etcd/releases )页面，用户可以选择需要的版本，或通过下载工具下载。

使用 curl 工具下载压缩包，并解压。
```bash
> curl -L  https://github.com/coreos/etcd/releases/download/v3.2.10/etcd-v3.2.10-linux-amd64.tar.gz -o etcd-v3.2.10-linux-amd64.tar.gz

> tar xzvf etcd-v3.2.10-linux-amd64.tar.gz

> cd etcd-v3.2.10-linux-amd64
```
解压后，可以看到文件包括:
```bash
> ls
Documentation README-etcdctl.md README.md READMEv2-etcdctl.md etcd etcdctl
```
其中etcd服务端，etcdctl是提供给用户的命令客户端，其他文件是支持文档。

下面将 etcd etcdctl 文件放到系统可执行目录（例如 /usr/local/bin/）。
```bash
> sudo cp etcd* /usr/local/bin/
```
默认 2379 端口处理客户端的请求，2380 端口用于集群各成员间的通信。启动 etcd 显示类似如下的信息：

启动etcd:
```bash
> ./etcd
2018-06-26 11:06:04.345228 I | etcdmain: etcd Version: 3.2.10
2018-06-26 11:06:04.345271 I | etcdmain: Git SHA: 694728c
2018-06-26 11:06:04.345296 I | etcdmain: Go Version: go1.8.5
2018-06-26 11:06:04.345303 I | etcdmain: Go OS/Arch: linux/amd64
2018-06-26 11:06:04.345310 I | etcdmain: setting maximum number of CPUs to 4, total number of available CPUs is 4
...

```
可以使用 etcdctl 命令进行测试，设置和获取键值 testkey: "first use etcd"，检查 etcd 服务是否启动成功：

```bash
> etcdctl member list

65388a54a71622c7: name=keke peerURLs=http://localhost:2380 clientURLs=http://localhost:2379 isLeader=true

> etcdctl set testkey "first use etcd"
first use etcd

> etcdctl get testkey
first use etcd
```
这样单节点Etcd就启动成功了!

#### Etcd集群安装

通常我们在安装和启动 etcd服务的时候，需要知道集群中其他节点的信息（一般是ip和port信息）。根据你是否可以提前知道每个节点的 ip，有3种不同的启动方案：
1. 静态配置：在启动 etcd server 的时候，通过 `--initial-cluster` 参数配置好所有的节点信息

2. 使用已有的 etcd cluster 来注册和启动，比如官方提供的 `discovery.etcd.io`

3.使用 DNS 启动

可以按照官方[Etcd集群安装文档](https://coreos.com/etcd/docs/latest/v2/clustering.html)安装,除此之外你也可以通过docker镜像来安装Etcd,
[镜像安装文档](https://coreos.com/etcd/docs/latest/v2/docker_guide.html).

常用配置的参数详细解析:
```markdown
* --name：方便理解的节点名称，默认为 default，在集群中应该保持唯一，可以使用 hostname.

* --data-dir：服务运行数据保存的路径，默认为 ${name}.etcd.

* --snapshot-count：指定有多少事务（transaction）被提交时，触发截取快照保存到磁盘.

* --heartbeat-interval：leader 多久发送一次心跳到 followers。默认值是 100ms.

* --eletion-timeout：重新投票的超时时间，如果 follow 在该时间间隔没有收到心跳包，会触发重新投票，默认为 1000 ms.

* --listen-peer-urls：和同伴通信的地址，比如 http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用 localhost！

* --listen-client-urls：对外提供服务的地址：比如 http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和 etcd 交互.

* --advertise-client-urls：对外公告的该节点客户端监听地址，这个值会告诉集群中其他节点.

* --initial-advertise-peer-urls：该节点同伴监听地址，这个值会告诉集群中其他节点.

* --initial-cluster：集群中所有节点的信息，格式为 node1=http://ip1:2380,node2=http://ip2:2380,…。注意：这里的 node1 是节点的 --name 指定的名字；后面的 ip1:2380 是 --initial-advertise-peer-urls 指定的值.

* --initial-cluster-state：新建集群的时候，这个值为 new；假如已经存在的集群，这个值为 existing.

* --initial-cluster-token：创建集群的 token，这个值每个集群保持唯一。这样的话，如果你要重新创建集群，即使配置和之前一样，也会再次生成新的集群和节点 uuid；否则会导致多个集群之间的冲突，造成未知的错误.
```
注意：以 --init 开头的配置都是在bootstrap集群的时候才会用到，所有的参数也可以通过环境变量进行设置，--my-flag 对应环境变量的 ETCD_MY_FLAG；但是命令行指定的参数会覆盖环境变量对应的值。在生产环境中配置 etcd集群，请使用 SSL 安全机制。



#### Etcd的使用
在每个etcd cluster都有若干个member组成的，每个 member 是一个独立运行的 etcd 实例，单台机器上可以运行多个 member。

在正常运行的状态下，集群中会有一个leader，其余的member都是followers。leader向 followers 同步日志,保证数据在各个member都有副本。leader还会定时向所有的 member 发送心跳报文，如果在规定的时间里 follower 没有收到心跳，就会重新进行选举

客户端所有的请求都会先发送给leader，leader 向所有的 followers 同步日志，等收到超过半数的确认后就把该日志存储到磁盘，并返回响应客户端。

每个 etcd 服务有三大主要部分组成：raft 实现、WAL 日志存储、数据的存储和索引。WAL 会在本地磁盘（就是之前提到的 --data-dir）上存储日志内容（wal file）和快照（snapshot）。
etcdctl是一个客户端，它能提供一些简洁的命令，供用户直接跟etcd服务打交道，而无需基于 HTTP API方式。可以方便我们在对服务进行测试或者手动修改数据库内容。

```bash
> etcd --version

etcd Version: 3.2.10
Git SHA: 694728c
Go Version: go1.8.5
Go OS/Arch: linux/amd64

>  etcdctl -h
NAME:
   etcdctl - A simple command line client for etcd.

WARNING:
   Environment variable ETCDCTL_API is not set; defaults to etcdctl v2.
   Set environment variable ETCDCTL_API=3 to use v3 API or ETCDCTL_API=2 to use v2 API.

USAGE:
   etcdctl [global options] command [command options] [arguments...]
   
VERSION:
   3.2.10
   
COMMANDS:
     backup          backup an etcd directory
     cluster-health  check the health of the etcd cluster
     mk              make a new key with a given value
     mkdir           make a new directory
     rm              remove a key or a directory
     rmdir           removes the key if it is an empty directory or a key-value pair
     get             retrieve the value of a key
     ls              retrieve a directory
     set             set the value of a key
     setdir          create a new directory or update an existing directory TTL
     update          update an existing key with a given value
     updatedir       update an existing directory
     watch           watch a key for changes
     exec-watch      watch a key for changes and exec an executable
     member          member add, remove and list subcommands
     user            user add, grant and revoke subcommands
     role            role add, grant and revoke subcommands
     auth            overall auth controls
     help, h         Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --debug                          output cURL commands which can be used to reproduce the request
   --no-sync                        don't synchronize cluster information before sending request
   --output simple, -o simple       output response in the given format (simple, `extended` or `json`) (default: "simple")
   --discovery-srv value, -D value  domain name to query for SRV records describing cluster endpoints
   --insecure-discovery             accept insecure SRV records describing cluster endpoints
   --peers value, -C value          DEPRECATED - "--endpoints" should be used instead
   --endpoint value                 DEPRECATED - "--endpoints" should be used instead
   --endpoints value                a comma-delimited list of machine addresses in the cluster (default: "http://127.0.0.1:2379,http://127.0.0.1:4001")
   --cert-file value                identify HTTPS client using this SSL certificate file
   --key-file value                 identify HTTPS client using this SSL key file
   --ca-file value                  verify certificates of HTTPS-enabled servers using this CA bundle
   --username value, -u value       provide username[:password] and prompt if password is not supplied.
   --timeout value                  connection timeout per request (default: 2s)
   --total-timeout value            timeout for the command execution (except watch) (default: 5s)
   --help, -h                       show help
   --version, -v                    print the version

```
命令选项详细:
```bash
--debug 输出CURL命令，显示执行命令的时候发起的请求
--no-sync 发出请求之前不同步集群信息
--output, -o 'simple' 输出内容的格式(simple 为原始信息，json 为进行json格式解码，易读性好一些)
--peers, -C 指定集群中的同伴信息，用逗号隔开(默认为: "127.0.0.1:4001")
--cert-file HTTPS下客户端使用的SSL证书文件
--key-file HTTPS下客户端使用的SSL密钥文件
--ca-file 服务端使用HTTPS时，使用CA文件进行验证
--help, -h 显示帮助命令信息
--version, -v 打印版本信息
```

etcd过HTTP API对外提供服务，这种方式非常方便测试（通过 curl 或者其他工具能实现etcd 交互），也很容易集成到各种语言中（每个语言封装 HTTP API 实现自己的 client 就行）。

* 获取 etcd 服务的版本信息
```bash
> http http://127.0.0.1:2379/version

HTTP/1.1 200 OK
Content-Length: 44
Content-Type: application/json
Date: Tue, 26 Jun 2018 05:43:30 GMT
{
    "etcdcluster": "3.1.0",
    "etcdserver": "3.1.0"
}

```

* key的增删查改

etcd 的数据按照树形的结构组织，类似于 linux 的文件系统，也有目录和文件的区别，不过一般被称为 nodes。数据的 endpoint 都是以 /v2/keys 开头（v2 表示当前 API 的版本），比如 /v2/keys/names/elegance。如果要创建一个值，只要使用 PUT 方法在对应的 url endpoint设置就可以了。如果对应的 key 已经存在，PUT也会对key进行更新。

```bash
>  http PUT http://127.0.0.1:2379/v2/keys/message value=="use  etcd"

HTTP/1.1 201 Created
Content-Length: 100
Content-Type: application/json
Date: Tue, 26 Jun 2018 05:45:28 GMT
X-Etcd-Cluster-Id: 9bfa9b14e11989b1
X-Etcd-Index: 27
X-Raft-Index: 50
X-Raft-Term: 24

{
    "action": "set",
    "node": {
        "createdIndex": 27,
        "key": "/message",
        "modifiedIndex": 27,
        "value": "use  etcd"
    }
}

```
通过 PUT 方法把 /message 设置为use etcd。返回的格式中，其中的字段：

* action：请求出发的动作，这里因为是新建一个 key 并设置它的值，所以是set。
* node.key：key 的 HTTP 路。
* node.value：请求处理之后，key 的值。
* node.createdIndex： createdIndex 是一个递增的值，每次有 key 被创建的时候会增加。
* node.modifiedIndex：同上，只不过每次有 key 被修改的时候增加。

除返回的 json 体外，上面的情况还包含了一些特殊的 HTTP 头部信息，这些信息说明了 etcd cluster 的一些情况。它们的具体含义如下：
* X-Etcd-Index：当前 etcd 集群的 index.
* X-Raft-Index：raft 集群的 index.
* X-Raft-Term：raft 集群的任期，每次有 leader 选举的时候，这个值就会增加.

查看信息比较简单，使用 GET 方法，url 指向要查看的值就行：
```bash
> http GET http://127.0.0.1:2379/v2/keys/message

HTTP/1.1 200 OK
Content-Length: 100
Content-Type: application/json
Date: Tue, 26 Jun 2018 05:50:28 GMT
X-Etcd-Cluster-Id: 9bfa9b14e11989b1
X-Etcd-Index: 29
X-Raft-Index: 52
X-Raft-Term: 24
{
    "action": "get",
    "node": {
        "createdIndex": 29,
        "key": "/message",
        "modifiedIndex": 29,
        "value": "use  etcd"
    }
}

```
这里的 action 变成了get，其他返回的值和上面的含义一样，略过不提。

使用PUT可用来更新key的值:
```bash
> http PUT http://127.0.0.1:2379/v2/keys/message value=="changed etcd value"

HTTP/1.1 200 OK
Content-Length: 196
Content-Type: application/json
Date: Tue, 26 Jun 2018 05:52:28 GMT
X-Etcd-Cluster-Id: 9bfa9b14e11989b1
X-Etcd-Index: 30
X-Raft-Index: 53
X-Raft-Term: 24

{
    "action": "set",
    "node": {
        "createdIndex": 30,
        "key": "/message",
        "modifiedIndex": 30,
        "value": "changed etcd value"
    },
    "prevNode": {
        "createdIndex": 29,
        "key": "/message",
        "modifiedIndex": 29,
        "value": "use  etcd"
    }
}

```
这次和第一次执行PUT命令不同的是，返回中多了一个字段 prevNode，它保存着更新之前该key的信息。它的格式和node是一样的，如果之前没有这个信息，这个字段会被省略。

我们如果需要删除key可以通过DELETE方法，比如我们要删除上面创建的字段:
```bash
> http DELETE http://127.0.0.1:2379/v2/keys/message

HTTP/1.1 200 OK
Content-Length: 179
Content-Type: application/json
Date: Tue, 26 Jun 2018 05:54:36 GMT
X-Etcd-Cluster-Id: 9bfa9b14e11989b1
X-Etcd-Index: 31
X-Raft-Index: 54
X-Raft-Term: 24

{
    "action": "delete",
    "node": {
        "createdIndex": 30,
        "key": "/message",
        "modifiedIndex": 31
    },
    "prevNode": {
        "createdIndex": 30,
        "key": "/message",
        "modifiedIndex": 30,
        "value": "changed etcd value"
    }
}

```
注意:这里的 action是delete，并且modifiedIndex增加了，但是createdIndex没有变化，因为这里是一个修改操作，而不是新建操作。

